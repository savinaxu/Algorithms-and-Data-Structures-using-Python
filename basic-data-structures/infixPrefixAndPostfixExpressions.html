<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous">
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous">
    </script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous">
    </script>
</head>
<body>
        <h1>3.9. Infix, Prefix and Postfix Expressions<a class="headerlink" href="#infix-prefix-and-postfix-expressions" title="Permalink to this headline">¶</a></h1>
        <p>When you write an arithmetic expression such as B * C, the form of the
        expression provides you with information so that you can interpret it
        correctly. In this case we know that the variable B is being multiplied
        by the variable C since the multiplication operator * appears between
        them in the expression. This type of notation is referred to as
        <strong>infix</strong> since the operator is <em>in between</em> the two operands that it is
        working on.</p>
        <p>Consider another infix example, A + B * C. The operators + and * still
        appear between the operands, but there is a problem. Which operands do
        they work on? Does the + work on A and B or does the * take B and C?
        The expression seems ambiguous.</p>
        <p>In fact, you have been reading and writing these types of expressions
        for a long time and they do not cause you any problem. The reason for
        this is that you know something about the operators + and *. Each
        operator has a <strong>precedence</strong> level. Operators of higher precedence are
        used before operators of lower precedence. The only thing that can
        change that order is the presence of parentheses. The precedence order
        for arithmetic operators places multiplication and division above
        addition and subtraction. If two operators of equal precedence appear,
        then a left-to-right ordering or associativity is used.</p>
        <p>Let’s interpret the troublesome expression A + B * C using operator
        precedence. B and C are multiplied first, and A is then added to that
        result. (A + B) * C would force the addition of A and B to be done
        first before the multiplication. In expression A + B + C, by precedence
        (via associativity), the leftmost + would be done first.</p>
        <p>Although all this may be obvious to you, remember that computers need to
        know exactly what operators to perform and in what order. One way to
        write an expression that guarantees there will be no confusion with
        respect to the order of operations is to create what is called a <strong>fully
        parenthesized</strong> expression. This type of expression uses one pair of
        parentheses for each operator. The parentheses dictate the order of
        operations; there is no ambiguity. There is also no need to remember any
        precedence rules.</p>
        <p>The expression A + B * C + D can be rewritten as ((A + (B * C)) + D)
        to show that the multiplication happens first, followed by the leftmost
        addition. A + B + C + D can be written as (((A + B) + C) + D) since the
        addition operations associate from left to right.</p>
        <p>There are two other very important expression formats that may not seem
        obvious to you at first. Consider the infix expression A + B. What would
        happen if we moved the operator before the two operands? The resulting
        expression would be + A B. Likewise, we could move the operator to the
        end. We would get A B +. These look a bit strange.</p>
        <p>These changes to the position of the operator with respect to the
        operands create two new expression formats, <strong>prefix</strong> and <strong>postfix</strong>.
        Prefix expression notation requires that all operators precede the two
        operands that they work on. Postfix, on the other hand, requires that
        its operators come after the corresponding operands. A few more examples
        should help to make this a bit clearer (see <a class="reference internal" href="#tbl-example1"><span class="std std-ref">Table 2</span></a>).</p>
        <p>A + B * C would be written as + A * B C in prefix. The multiplication
        operator comes immediately before the operands B and C, denoting that *
        has precedence over +. The addition operator then appears before the A
        and the result of the multiplication.</p>
        <p>In postfix, the expression would be A B C * +. Again, the order of
        operations is preserved since the * appears immediately after the B and
        the C, denoting that * has precedence, with + coming after. Although
        the operators moved and now appear either before or after their
        respective operands, the order of the operands stayed exactly the same
        relative to one another.</p>
        <table border="1" class="docutils" id="id1">
        <span id="tbl-example1"></span><caption><span class="caption-text"><strong>Table 2: Examples of Infix, Prefix, and Postfix</strong></span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
        <colgroup>
        <col width="37%" />
        <col width="31%" />
        <col width="32%" />
        </colgroup>
        <thead valign="bottom">
        <tr class="row-odd"><th class="head"><strong>Infix Expression</strong></th>
        <th class="head"><strong>Prefix Expression</strong></th>
        <th class="head"><strong>Postfix Expression</strong></th>
        </tr>
        </thead>
        <tbody valign="top">
        <tr class="row-even"><td>A + B</td>
        <td>+ A B</td>
        <td>A B +</td>
        </tr>
        <tr class="row-odd"><td>A + B * C</td>
        <td>+ A * B C</td>
        <td>A B C * +</td>
        </tr>
        </tbody>
        </table>
        <p>Now consider the infix expression (A + B) * C. Recall that in this
        case, infix requires the parentheses to force the performance of the
        addition before the multiplication. However, when A + B was written in
        prefix, the addition operator was simply moved before the operands, + A
        B. The result of this operation becomes the first operand for the
        multiplication. The multiplication operator is moved in front of the
        entire expression, giving us * + A B C. Likewise, in postfix A B +
        forces the addition to happen first. The multiplication can be done to
        that result and the remaining operand C. The proper postfix expression
        is then A B + C *.</p>
        <p>Consider these three expressions again (see <a class="reference internal" href="#tbl-parexample"><span class="std std-ref">Table 3</span></a>).
        Something very important has happened. Where did the parentheses go? Why
        don’t we need them in prefix and postfix? The answer is that the
        operators are no longer ambiguous with respect to the operands that they
        work on. Only infix notation requires the additional symbols. The order
        of operations within prefix and postfix expressions is completely
        determined by the position of the operator and nothing else. In many
        ways, this makes infix the least desirable notation to use.</p>
        <table border="1" class="docutils" id="id2">
        <span id="tbl-parexample"></span><caption><span class="caption-text"><strong>Table 3: An Expression with Parentheses</strong></span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
        <colgroup>
        <col width="37%" />
        <col width="31%" />
        <col width="32%" />
        </colgroup>
        <thead valign="bottom">
        <tr class="row-odd"><th class="head"><strong>Infix Expression</strong></th>
        <th class="head"><strong>Prefix Expression</strong></th>
        <th class="head"><strong>Postfix Expression</strong></th>
        </tr>
        </thead>
        <tbody valign="top">
        <tr class="row-even"><td>(A + B) * C</td>
        <td>* + A B C</td>
        <td>A B + C *</td>
        </tr>
        </tbody>
        </table>
        <p><a class="reference internal" href="#tbl-example3"><span class="std std-ref">Table 4</span></a> shows some additional examples of infix expressions and
        the equivalent prefix and postfix expressions. Be sure that you
        understand how they are equivalent in terms of the order of the
        operations being performed.</p>
        <table border="1" class="docutils" id="id3">
        <span id="tbl-example3"></span><caption><span class="caption-text"><strong>Table 4: Additional Examples of Infix, Prefix, and Postfix</strong></span><a class="headerlink" href="#id3" title="Permalink to this table">¶</a></caption>
        <colgroup>
        <col width="37%" />
        <col width="31%" />
        <col width="32%" />
        </colgroup>
        <thead valign="bottom">
        <tr class="row-odd"><th class="head"><strong>Infix Expression</strong></th>
        <th class="head"><strong>Prefix Expression</strong></th>
        <th class="head"><strong>Postfix Expression</strong></th>
        </tr>
        </thead>
        <tbody valign="top">
        <tr class="row-even"><td>A + B * C + D</td>
        <td>+ + A * B C D</td>
        <td>A B C * + D +</td>
        </tr>
        <tr class="row-odd"><td>(A + B) * (C + D)</td>
        <td>* + A B + C D</td>
        <td>A B + C D + *</td>
        </tr>
        <tr class="row-even"><td>A * B + C * D</td>
        <td>+ * A B * C D</td>
        <td>A B * C D * +</td>
        </tr>
        <tr class="row-odd"><td>A + B + C + D</td>
        <td>+ + + A B C D</td>
        <td>A B + C + D +</td>
        </tr>
        </tbody>
        </table>
        <div class="section" id="conversion-of-infix-expressions-to-prefix-and-postfix">
        <h2>3.9.1. Conversion of Infix Expressions to Prefix and Postfix<a class="headerlink" href="#conversion-of-infix-expressions-to-prefix-and-postfix" title="Permalink to this headline">¶</a></h2>
        <p>So far, we have used ad hoc methods to convert between infix expressions
        and the equivalent prefix and postfix expression notations. As you might
        expect, there are algorithmic ways to perform the conversion that allow
        any expression of any complexity to be correctly transformed.</p>
        <p>The first technique that we will consider uses the notion of a fully
        parenthesized expression that was discussed earlier. Recall that A + B
        * C can be written as (A + (B * C)) to show explicitly that the
        multiplication has precedence over the addition. On closer observation,
        however, you can see that each parenthesis pair also denotes the
        beginning and the end of an operand pair with the corresponding operator
        in the middle.</p>
        <p>Look at the right parenthesis in the subexpression (B * C) above. If we
        were to move the multiplication symbol to that position and remove the
        matching left parenthesis, giving us B C *, we would in effect have
        converted the subexpression to postfix notation. If the addition
        operator were also moved to its corresponding right parenthesis position
        and the matching left parenthesis were removed, the complete postfix
        expression would result (see <a class="reference internal" href="#fig-moveright"><span class="std std-ref">Figure 6</span></a>).</p>
        <div class="figure align-center" id="id4">
        <span id="fig-moveright"></span><img alt="../_images/moveright.png" src="../_images/moveright.png" />
        <p class="caption"><span class="caption-text">Figure 6: Moving Operators to the Right for Postfix Notation</span></p>
        </div>
        <p>If we do the same thing but instead of moving the symbol to the position
        of the right parenthesis, we move it to the left, we get prefix notation
        (see <a class="reference internal" href="#fig-moveleft"><span class="std std-ref">Figure 7</span></a>). The position of the parenthesis pair is
        actually a clue to the final position of the enclosed operator.</p>
        <div class="figure align-center" id="id5">
        <span id="fig-moveleft"></span><img alt="../_images/moveleft.png" src="../_images/moveleft.png" />
        <p class="caption"><span class="caption-text">Figure 7: Moving Operators to the Left for Prefix Notation</span></p>
        </div>
        <p>So in order to convert an expression, no matter how complex, to either
        prefix or postfix notation, fully parenthesize the expression using the
        order of operations. Then move the enclosed operator to the position of
        either the left or the right parenthesis depending on whether you want
        prefix or postfix notation.</p>
        <p>Here is a more complex expression: (A + B) * C - (D - E) * (F + G).
        <a class="reference internal" href="#fig-complexmove"><span class="std std-ref">Figure 8</span></a> shows the conversion to postfix and prefix
        notations.</p>
        <div class="figure align-center" id="id6">
        <span id="fig-complexmove"></span><img alt="../_images/complexmove.png" src="../_images/complexmove.png" />
        <p class="caption"><span class="caption-text">Figure 8: Converting a Complex Expression to Prefix and Postfix Notations</span></p>
        </div>
        </div>
        <div class="section" id="general-infix-to-postfix-conversion">
        <h2>3.9.2. General Infix-to-Postfix Conversion<a class="headerlink" href="#general-infix-to-postfix-conversion" title="Permalink to this headline">¶</a></h2>
        <p>We need to develop an algorithm to convert any infix expression to a
        postfix expression. To do this we will look closer at the conversion
        process.</p>
        <p>Consider once again the expression A + B * C. As shown above,
        A B C * + is the postfix equivalent. We have already noted that the
        operands A, B, and C stay in their relative positions. It is only the
        operators that change position. Let’s look again at the operators in the
        infix expression. The first operator that appears from left to right is
        +. However, in the postfix expression, + is at the end since the next
        operator, *, has precedence over addition. The order of the operators
        in the original expression is reversed in the resulting postfix
        expression.</p>
        <p>As we process the expression, the operators have to be saved somewhere
        since their corresponding right operands are not seen yet. Also, the
        order of these saved operators may need to be reversed due to their
        precedence. This is the case with the addition and the multiplication in
        this example. Since the addition operator comes before the
        multiplication operator and has lower precedence, it needs to appear
        after the multiplication operator is used. Because of this reversal of
        order, it makes sense to consider using a stack to keep the operators
        until they are needed.</p>
        <p>What about (A + B) * C? Recall that A B + C * is the postfix
        equivalent. Again, processing this infix expression from left to right,
        we see + first. In this case, when we see *, + has already been placed
        in the result expression because it has precedence over * by virtue of
        the parentheses. We can now start to see how the conversion algorithm
        will work. When we see a left parenthesis, we will save it to denote
        that another operator of high precedence will be coming. That operator
        will need to wait until the corresponding right parenthesis appears to
        denote its position (recall the fully parenthesized technique). When
        that right parenthesis does appear, the operator can be popped from the
        stack.</p>
        <p>As we scan the infix expression from left to right, we will use a stack
        to keep the operators. This will provide the reversal that we noted in
        the first example. The top of the stack will always be the most recently
        saved operator. Whenever we read a new operator, we will need to
        consider how that operator compares in precedence with the operators, if
        any, already on the stack.</p>
        <p>Assume the infix expression is a string of tokens delimited by spaces.
        The operator tokens are *, /, +, and -, along with the left and right
        parentheses, ( and ). The operand tokens are the single-character
        identifiers A, B, C, and so on. The following steps will produce a
        string of tokens in postfix order.</p>
        <ol class="arabic simple">
        <li>Create an empty stack called <code class="docutils literal"><span class="pre">opstack</span></code> for keeping operators.
        Create an empty list for output.</li>
        <li>Convert the input infix string to a list by using the string method
        <code class="docutils literal"><span class="pre">split</span></code>.</li>
        <li>Scan the token list from left to right.<ul>
        <li>If the token is an operand, append it to the end of the output
        list.</li>
        <li>If the token is a left parenthesis, push it on the <code class="docutils literal"><span class="pre">opstack</span></code>.</li>
        <li>If the token is a right parenthesis, pop the <code class="docutils literal"><span class="pre">opstack</span></code> until the
        corresponding left parenthesis is removed. Append each operator to
        the end of the output list.</li>
        <li>If the token is an operator, *, /, +, or -, push it on the
        <code class="docutils literal"><span class="pre">opstack</span></code>. However, first remove any operators already on the
        <code class="docutils literal"><span class="pre">opstack</span></code> that have higher or equal precedence and append them
        to the output list.</li>
        </ul>
        </li>
        <li>When the input expression has been completely processed, check the
        <code class="docutils literal"><span class="pre">opstack</span></code>. Any operators still on the stack can be removed and
        appended to the end of the output list.</li>
        </ol>
        <p><a class="reference internal" href="#fig-intopost"><span class="std std-ref">Figure 9</span></a> shows the conversion algorithm working on the
        expression A * B + C * D. Note that the first * operator is removed
        upon seeing the + operator. Also, + stays on the stack when the second
        * occurs, since multiplication has precedence over addition. At the end
        of the infix expression the stack is popped twice, removing both
        operators and placing + as the last operator in the postfix expression.</p>
        <div class="figure align-center" id="id7">
        <span id="fig-intopost"></span><img alt="../_images/intopost.png" src="../_images/intopost.png" />
        <p class="caption"><span class="caption-text">Figure 9: Converting A * B + C * D to Postfix Notation</span></p>
        </div>
        <p>In order to code the algorithm in Python, we will use a dictionary
        called <code class="docutils literal"><span class="pre">prec</span></code> to hold the precedence values for the operators. This
        dictionary will map each operator to an integer that can be compared
        against the precedence levels of other operators (we have arbitrarily
        used the integers 3, 2, and 1). The left parenthesis will receive the
        lowest value possible. This way any operator that is compared against it
        will have higher precedence and will be placed on top of it.
        Line 15 defines the operands to be any upper-case character or digit.
        The complete conversion function is
        shown in <a class="reference internal" href="#lst-intopost"><span class="std std-ref">ActiveCode 1</span></a>.</p>
        
        <div data-childcomponent="intopost" class="explainer ac_section alert alert-warning">
        
        <textarea data-component="activecode" id=intopost data-lang="python"    data-timelimit=25000   data-audio=''     data-caption='Converting Infix Expressions to Postfix Expressions'>
        from pythonds.basic.stack import Stack
        
        def infixToPostfix(infixexpr):
            prec = {}
            prec["*"] = 3
            prec["/"] = 3
            prec["+"] = 2
            prec["-"] = 2
            prec["("] = 1
            opStack = Stack()
            postfixList = []
            tokenList = infixexpr.split()
        
            for token in tokenList:
                if token in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" or token in "0123456789":
                    postfixList.append(token)
                elif token == '(':
                    opStack.push(token)
                elif token == ')':
                    topToken = opStack.pop()
                    while topToken != '(':
                        postfixList.append(topToken)
                        topToken = opStack.pop()
                else:
                    while (not opStack.isEmpty()) and \
                       (prec[opStack.peek()] >= prec[token]):
                          postfixList.append(opStack.pop())
                    opStack.push(token)
        
            while not opStack.isEmpty():
                postfixList.append(opStack.pop())
            return " ".join(postfixList)
        
        print(infixToPostfix("A * B + C * D"))
        print(infixToPostfix("( A + B ) * C - ( D - E ) * ( F + G )"))
        </textarea>
        </div>
        <hr class="docutils" />
        <p>A few more examples of execution in the Python shell are shown below.</p>
        <div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">infixtopostfix</span><span class="p">(</span><span class="s2">&quot;( A + B ) * ( C + D )&quot;</span><span class="p">)</span>
        <span class="go">&#39;A B + C D + *&#39;</span>
        <span class="gp">&gt;&gt;&gt; </span><span class="n">infixtopostfix</span><span class="p">(</span><span class="s2">&quot;( A + B ) * C&quot;</span><span class="p">)</span>
        <span class="go">&#39;A B + C *&#39;</span>
        <span class="gp">&gt;&gt;&gt; </span><span class="n">infixtopostfix</span><span class="p">(</span><span class="s2">&quot;A + B * C&quot;</span><span class="p">)</span>
        <span class="go">&#39;A B C * +&#39;</span>
        <span class="go">&gt;&gt;&gt;</span>
        </pre></div>
        </div>
        </div>
        <div class="section" id="postfix-evaluation">
        <h2>3.9.3. Postfix Evaluation<a class="headerlink" href="#postfix-evaluation" title="Permalink to this headline">¶</a></h2>
        <p>As a final stack example, we will consider the evaluation of an
        expression that is already in postfix notation. In this case, a stack is
        again the data structure of choice. However, as you scan the postfix
        expression, it is the operands that must wait, not the operators as in
        the conversion algorithm above. Another way to think about the solution
        is that whenever an operator is seen on the input, the two most recent
        operands will be used in the evaluation.</p>
        <p>To see this in more detail, consider the postfix expression
        <code class="docutils literal"><span class="pre">4</span> <span class="pre">5</span> <span class="pre">6</span> <span class="pre">*</span> <span class="pre">+</span></code>. As you scan the expression from left to right, you first
        encounter the operands 4 and 5. At this point, you are still unsure what
        to do with them until you see the next symbol. Placing each on the stack
        ensures that they are available if an operator comes next.</p>
        <p>In this case, the next symbol is another operand. So, as before, push it
        and check the next symbol. Now we see an operator, *. This means that
        the two most recent operands need to be used in a multiplication
        operation. By popping the stack twice, we can get the proper operands
        and then perform the multiplication (in this case getting the result
        30).</p>
        <p>We can now handle this result by placing it back on the stack so that it
        can be used as an operand for the later operators in the expression.
        When the final operator is processed, there will be only one value left
        on the stack. Pop and return it as the result of the expression.
        <a class="reference internal" href="#fig-evalpost1"><span class="std std-ref">Figure 10</span></a> shows the stack contents as this entire example
        expression is being processed.</p>
        <div class="figure align-center" id="id8">
        <span id="fig-evalpost1"></span><img alt="../_images/evalpostfix1.png" src="../_images/evalpostfix1.png" />
        <p class="caption"><span class="caption-text">Figure 10: Stack Contents During Evaluation</span></p>
        </div>
        <p><a class="reference internal" href="#fig-evalpost2"><span class="std std-ref">Figure 11</span></a> shows a slightly more complex example, 7 8 + 3 2
        + /. There are two things to note in this example. First, the stack size
        grows, shrinks, and then grows again as the subexpressions are
        evaluated. Second, the division operation needs to be handled carefully.
        Recall that the operands in the postfix expression are in their original
        order since postfix changes only the placement of operators. When the
        operands for the division are popped from the stack, they are reversed.
        Since division is <em>not</em> a commutative operator, in other words
        <span class="math">\(15/5\)</span> is not the same as <span class="math">\(5/15\)</span>, we must be sure that
        the order of the operands is not switched.</p>
        <div class="figure align-center" id="id9">
        <span id="fig-evalpost2"></span><img alt="../_images/evalpostfix2.png" src="../_images/evalpostfix2.png" />
        <p class="caption"><span class="caption-text">Figure 11: A More Complex Example of Evaluation</span></p>
        </div>
        <p>Assume the postfix expression is a string of tokens delimited by spaces.
        The operators are *, /, +, and - and the operands are assumed to be
        single-digit integer values. The output will be an integer result.</p>
        <ol class="arabic simple">
        <li>Create an empty stack called <code class="docutils literal"><span class="pre">operandStack</span></code>.</li>
        <li>Convert the string to a list by using the string method <code class="docutils literal"><span class="pre">split</span></code>.</li>
        <li>Scan the token list from left to right.<ul>
        <li>If the token is an operand, convert it from a string to an integer
        and push the value onto the <code class="docutils literal"><span class="pre">operandStack</span></code>.</li>
        <li>If the token is an operator, *, /, +, or -, it will need two
        operands. Pop the <code class="docutils literal"><span class="pre">operandStack</span></code> twice. The first pop is the
        second operand and the second pop is the first operand. Perform
        the arithmetic operation. Push the result back on the
        <code class="docutils literal"><span class="pre">operandStack</span></code>.</li>
        </ul>
        </li>
        <li>When the input expression has been completely processed, the result
        is on the stack. Pop the <code class="docutils literal"><span class="pre">operandStack</span></code> and return the value.</li>
        </ol>
        <p>The complete function for the evaluation of postfix expressions is shown
        in <a class="reference internal" href="#lst-postfixeval"><span class="std std-ref">ActiveCode 2</span></a>. To assist with the arithmetic, a helper
        function <code class="docutils literal"><span class="pre">doMath</span></code> is defined that will take two operands and an
        operator and then perform the proper arithmetic operation.</p>
        
        <div data-childcomponent="postfixeval" class="explainer ac_section alert alert-warning">
        
        <textarea data-component="activecode" id=postfixeval data-lang="python"    data-timelimit=25000   data-audio=''     data-caption='Postfix Evaluation'>
        from pythonds.basic.stack import Stack
        
        def postfixEval(postfixExpr):
            operandStack = Stack()
            tokenList = postfixExpr.split()
        
            for token in tokenList:
                if token in "0123456789":
                    operandStack.push(int(token))
                else:
                    operand2 = operandStack.pop()
                    operand1 = operandStack.pop()
                    result = doMath(token,operand1,operand2)
                    operandStack.push(result)
            return operandStack.pop()
        
        def doMath(op, op1, op2):
            if op == "*":
                return op1 * op2
            elif op == "/":
                return op1 / op2
            elif op == "+":
                return op1 + op2
            else:
                return op1 - op2
        
        print(postfixEval('7 8 + 3 2 + /'))
        </textarea>
        </div>
        <p>It is important to note that in both the postfix conversion and the
        postfix evaluation programs we assumed that there were no errors in the
        input expression. Using these programs as a starting point, you can
        easily see how error detection and reporting can be included. We leave
        this as an exercise at the end of the chapter.</p>
        <div class="admonition-self-check admonition">
        <p class="first admonition-title">Self Check</p>
        
                <p data-component="fillintheblank" data-casei="false" id="postfix1">
                    
                <span data-blank>
                    Without using the activecode infixToPostfix function, convert the following expression to postfix  <code class="docutils literal"><span class="pre">10</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span> <span class="pre">/</span> <span class="pre">(16</span> <span class="pre">-</span> <span class="pre">4)</span></code>
                <span data-feedback="regex" style="display: none" id="pfblank1_feedback1">10.*3.*5.*16.*4</span>
                <span data-feedback="text" style="display: none" for="pfblank1_feedback1">The numbers appear to be in the correct order check your operators</span>
                    
                <span data-feedback="regex" style="display: none" id="pfblank1_feedback2">.*</span>
                <span data-feedback="text" style="display: none" for="pfblank1_feedback2">Remember the numbers will be in the same order as the original equation</span>
                    
                <span data-answer style="display: none" id="pfblank1_answer">\\b10\\s+3\\s+5\\s*\\*\\s*16\\s+4\\s*-\\s*/\\s*\\+</span>
                </span>
                
                </p>
                    
                <p data-component="fillintheblank" data-casei="false" id="postfix2">
                    
                <span data-blank>
                    What is the result of evaluating the following: <code class="docutils literal"><span class="pre">17</span> <span class="pre">10</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">9</span> <span class="pre">/</span> <span class="pre">==</span></code>
                <span data-feedback="regex" style="display: none" id="pfblank2_feedback1">.*</span>
                <span data-feedback="text" style="display: none" for="pfblank2_feedback1">Remember to push each intermediate result back on the stack</span>
                    
                <span data-answer style="display: none" id="pfblank2_answer">\\b9\\b</span>
                </span>
                
                </p>
                    
                <p data-component="fillintheblank" data-casei="false" id="postfix3">
                    
                <span data-blank>
                    Modify the infixToPostfix function so that it can convert the following expression:  <code class="docutils literal"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">3</span> <span class="pre">**</span> <span class="pre">(4</span> <span class="pre">-</span> <span class="pre">2)</span></code>   Paste the answer here:
                <span data-feedback="regex" style="display: none" id="pfblank3_feedback1">.*</span>
                <span data-feedback="text" style="display: none" for="pfblank3_feedback1">Hint: You only need to add one line to the function!!</span>
                    
                <span data-answer style="display: none" id="pfblank3_answer">5\\s+3\\s+4\\s+2\\s*-\\s*\\^\\s*\\*</span>
                </span>
                
                </p>
                    </div>
        <div id="video_Stack3" class="video_popup" >
        <video controls preload="none"  poster="../_static/activecodethumb.png">
            <source src="http://media.interactivepython.org/pythondsVideos/Stack3.mov" type="video/mp4"></source>
            <source src="http://media.interactivepython.org/pythondsVideos/Stack3.webm" type="video/webm"></source>
            No supported video types
        </video>
        </div>
        <script>
           jQuery(function($) {
              var rb = new RunestoneBase();
              $('#video_Stack3_thumb').click(function(e) {
                 $('#video_Stack3').show();
                 $('#video_Stack3_thumb').hide();
                 rb.logBookEvent({'event':'video','act':'play','div_id': 'video_Stack3'});
                 // Log the run event
              });
              $('#video_Stack3 video').one("click", function(){
                this.play();
              });
              $('#video_Stack3 video').one("play", function(){
                rb.logBookEvent({'event':'video','act':'play','div_id': 'video_Stack3'});
              });
           });
        </script>
        </div>
</body>
</html> 